%
% API Documentation
% Module VLBACal
%
% Generated by epydoc 2.1
% [Tue Oct 12 12:12:03 2010]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{VLBACal \textit{(module)}|(}
\section{Module VLBACal}

    \label{VLBACal}
\begin{alltt}
Functions for calibrating and editing VLBA data\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{VLBACal:AllDest}
    \index{VLBACal \textit{(module)}!AllDest \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{AllDest}(\textit{err}, \textit{disk}=\texttt{N\-o\-n\-e\-}, \textit{Atype}=\texttt{'\-~\-~\-'\-}, \textit{Aname}=\texttt{'\-~\-~\-~\-~\-~\-~\-~\-~\-~\-~\-~\-~\-'\-}, \textit{Aclass}=\texttt{'\-~\-~\-~\-~\-~\-~\-'\-}, \textit{Aseq}=\texttt{0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Delete AIPS files matching a pattern

Strings use AIPS wild cards:
    blank ={\textgreater} any
    '?'   ={\textgreater} one of any character
    "*"   ={\textgreater} arbitrary string
disk      = AIPS disk number, 0={\textgreater}all
Atype     = AIPS entry type, 'MA' or 'UV'; '  ={\textgreater} all
Aname     = desired AIPS name, using AIPS wildcards, None -{\textgreater} don't check
Aclass    = desired AIPS class, using AIPS wildcards, None -{\textgreater} don't check
Aseq      = desired AIPS sequence, 0={\textgreater} any\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:day2dhms}
    \index{VLBACal \textit{(module)}!day2dhms \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{day2dhms}(\textit{tim})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
convert a time in days to a string as d/hh:mm:ss.s

Returns time as string:  "d/hh:mm:ss.s"
tim       time in days\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:dhms2day}
    \index{VLBACal \textit{(module)}!dhms2day \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{dhms2day}(\textit{st})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
convert a time string in d/hh:mm:ss.s to days

Returns time in days
st        time string as "d/hh:mm:ss.s"\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:FetchObject}
    \index{VLBACal \textit{(module)}!FetchObject \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{FetchObject}(\textit{file})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Fetch python object from a pickle file

returns python object
file     = pickle file name\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:imstat}
    \index{VLBACal \textit{(module)}!imstat \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{imstat}(\textit{inImage}, \textit{err}, \textit{blc}=\texttt{[\-1\-,\-~\-1\-,\-~\-1\-,\-~\-1\-,\-~\-1\-]\-}, \textit{trc}=\texttt{[\-0\-,\-~\-0\-,\-~\-0\-,\-~\-0\-,\-~\-0\-]\-}, \textit{logfile}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Get statistics in a specified region of an image plane

Returns dictionary with statistics of selected region with entries:
    Mean    = Mean value
    RMSHist = RMS value from a histogram analysis
    RMS     = Simple RMS value
    Max     = maximum value
    MaxPos  = pixel of maximum value
    Min     = minimum value
    MinPos  = pixel of minimum value
    Flux    = Flux density if CLEAN beam given, else -1
    BeamArea= CLEAN Beam area in pixels
inImage   = Python Image object, created with getname, getFITS
err      = Obit error/message stack
blc      = bottom left corner pixel (1-rel)
trc      = top right corner pixel (1-rel)
logfile  = file to write results to\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:printMess}
    \index{VLBACal \textit{(module)}!printMess \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{printMess}(\textit{message}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Print message, optionally in logfile


message = message to print
logfile = logfile for message\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:SaveObject}
    \index{VLBACal \textit{(module)}!SaveObject \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{SaveObject}(\textit{pyobj}, \textit{file}, \textit{update})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Save python object to a pickle file

pyobj    = python object to save
file     = pickle file name
update   = If True update, otherwise only if file doesn't already exist\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:set2name}
    \index{VLBACal \textit{(module)}!set2name \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{set2name}(\textit{in2}, \textit{out})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Copy file definition from in2 to out as in2...

Supports both FITS and AIPS
Copies Data type and file name, disk, class etc
in2  = Obit data object, created with getname, getFITS
out  = ObitTask object,\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:setname}
    \index{VLBACal \textit{(module)}!setname \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{setname}(\textit{inn}, \textit{out})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Copy file definition from inn to out as in...

Supports both FITS and AIPS
Copies Data type and file name, disk, class etc
inn  = Obit data object, created with getname, getFITS
out  = ObitTask object,\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:unique}
    \index{VLBACal \textit{(module)}!unique \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{unique}(\textit{inn})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Removes duplicate entries from an array of strings

Returns an array of strings, also removes null and blank strings
as well as leading or trailing blanks
inn  = list of strings with possible redundancies\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAAIPSName}
    \index{VLBACal \textit{(module)}!VLBAAIPSName \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAAIPSName}(\textit{project}, \textit{session})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Derive AIPS Name

AIPS file name will be project+session with project truncated to fit in 12 characters
project    = project name
session    = session code\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAAmpCal}
    \index{VLBACal \textit{(module)}!VLBAAmpCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAAmpCal}(\textit{uv}, \textit{err}, \textit{solInt}=\texttt{0\-.\-5\-}, \textit{smoTimeA}=\texttt{1\-4\-4\-0\-.\-0\-}, \textit{smoTimeP}=\texttt{1\-0\-.\-0\-}, \textit{calSou}=\texttt{N\-o\-n\-e\-}, \textit{CalModel}=\texttt{N\-o\-n\-e\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{FreqID}=\texttt{1\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{minSNR}=\texttt{5\-.\-0\-}, \textit{refAnt}=\texttt{0\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{doSNPlot}=\texttt{F\-a\-l\-s\-e\-}, \textit{plotFile}=\texttt{'\-.\-/\-A\-m\-p\-C\-a\-l\-.\-p\-s\-'\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Amplitude calibration

Determine amplitude calibratiion from a list of calibrators
Solutions smoothed to smoTime
Apply this SN table to the highest CL table writing a new CL table (Obit/CLCal)
Returns task error code, 0=OK, else failed
err        = Python Obit Error/message stack
calSou     = Source name or list of names to use
CalModel = python dict with image model dicts keyed on calibrator name
           image object = "Image"
           also optional
           "nfield",    Calibrator model  No. maps to use for model
           "CCver",     Calibrator model CC file version
           "BComp",     Calibrator model First CLEAN comp to use, 1/field
           "EComp"      Calibrator model  Last CLEAN comp to use, 0={\textgreater}all
           "Cmethod"    Calibrator model Modeling method, 'DFT','GRID','    '
           "CModel"     Calibrator model Model type: 'COMP','IMAG'
           "CalFlux"    Calibrator model  Lowest CC component used
           "modelFlux"  if ["Image"]=None, Parameterized model flux density (Jy)
           "modepPos"   if ["Image"]=None, Parameterized model Model position offset (asec)
           "modelParm"  if ["Image"]=None, Parameterized model Model parameters
                        (maj, min, pa, type)
timeRange  = timerange of data to use
solInt     = Calib solution interval (min)
smoTimeA   = Amplitude Smoothing time applied to SN table (min)
smoTimeP   = Phase Smoothing time applied to SN table (min)
FreqID     = Frequency group identifier
minSNR     = minimum acceptable SNR in Calib
refAnt     = Reference antenna
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
doSNPlot   = If True make plots of SN gains
plotFile   = Name of postscript file for plots
nThreads   = Max. number of threads to use
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAApplyCal}
    \index{VLBACal \textit{(module)}!VLBAApplyCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAApplyCal}(\textit{uv}, \textit{err}, \textit{SNver}=\texttt{0\-}, \textit{CLin}=\texttt{0\-}, \textit{CLout}=\texttt{0\-}, \textit{maxInter}=\texttt{2\-4\-0\-.\-0\-}, \textit{logfile}=\texttt{N\-o\-n\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Applies an SN table to a CL table and writes another

Returns task error code, 0=OK, else failed
uv       = UV data object to clear
err      = Obit error/message stack
SNver    = SN table to apply, 0={\textgreater}highest
CLin     = input CL table, 0={\textgreater}highest
CLout    = output CL table, 0={\textgreater}create new
maxInter = Max time (min) over which to interpolate
logfile  = logfile for messages
check    = Only check script, don't execute tasks
debug    = show input, ObitTasks debug\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAAutoFlag}
    \index{VLBACal \textit{(module)}!VLBAAutoFlag \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAAutoFlag}(\textit{uv}, \textit{target}, \textit{err}, \textit{doCalib}=\texttt{0\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{flagTab}=\texttt{2\-}, \textit{VClip}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{IClip}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{RMSClip}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{RMSAvg}=\texttt{0\-.\-0\-}, \textit{maxBad}=\texttt{0\-.\-2\-5\-}, \textit{timeAvg}=\texttt{1\-.\-0\-}, \textit{doFD}=\texttt{F\-a\-l\-s\-e\-}, \textit{FDmaxAmp}=\texttt{0\-.\-0\-}, \textit{FDmaxV}=\texttt{0\-.\-0\-}, \textit{FDwidMW}=\texttt{5\-}, \textit{FDmaxRMS}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{FDmaxRes}=\texttt{6\-.\-0\-}, \textit{FDmaxResBL}=\texttt{6\-.\-0\-}, \textit{FDbaseSel}=\texttt{[\-0\-,\-~\-0\-,\-~\-0\-,\-~\-0\-]\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Does Automated flagging

Flag data based on any of a number of criteria
See documentation for task AutoFlag for details
Returns task error code, 0=OK, else failed
uv         = UV data object to flag
target     = Target source name or list of names, blank = all
err        = Obit error/message stack
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
flagTab    = Output Flagging table version
VClip      = If {\textgreater} 0.0 VPol clipping level
IClip      = If {\textgreater} 0.0 IPol clipping level
RMSClip    = Abs and fractional clip levels for
             Time domain RMS filtering
RMSAvg     = Max RMS/Avg for time domain RMS filtering
maxBad     = Maximum fraction of baselines for
             correlator or antenna to be
             flagged before all are flagged
timeAvg    = Flagging interval (min)
doFD       = do frequency domain editing?
FDmaxAmp   = Maximum average amplitude
FDmaxV     = Maximum average VPol amp
FDwidMW    = Width of the median window
FDmaxRMS   = Channel RMS limits
FDmaxRes   = Max. residual flux in sigma
FDmaxResBL = Max. baseline residual
FDbaseSel  =  Channels for baseline fit (start, end, increment, IF)
check      = Only check script, don't execute tasks
debug      = Run tasks debug, show input
logfile    = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBABPass}
    \index{VLBACal \textit{(module)}!VLBABPass \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBABPass}(\textit{uv}, \textit{BPCal}, \textit{err}, \textit{CalModel}=\texttt{N\-o\-n\-e\-}, \textit{newBPVer}=\texttt{1\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{doCalib}=\texttt{2\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{doCenter1}=\texttt{N\-o\-n\-e\-}, \textit{BChan1}=\texttt{1\-}, \textit{EChan1}=\texttt{0\-}, \textit{BChan2}=\texttt{1\-}, \textit{EChan2}=\texttt{0\-}, \textit{ChWid2}=\texttt{1\-}, \textit{solInt1}=\texttt{0\-.\-0\-}, \textit{solInt2}=\texttt{0\-.\-0\-}, \textit{solMode}=\texttt{'\-A\-\&\-P\-'\-}, \textit{refAnt}=\texttt{0\-}, \textit{ampScalar}=\texttt{F\-a\-l\-s\-e\-}, \textit{specIndex}=\texttt{0\-.\-0\-}, \textit{doAuto}=\texttt{F\-a\-l\-s\-e\-}, \textit{doPol}=\texttt{F\-a\-l\-s\-e\-}, \textit{avgPol}=\texttt{F\-a\-l\-s\-e\-}, \textit{avgIF}=\texttt{F\-a\-l\-s\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Bandpass calibration

Determine bandpass from a short section of strong source data.
Calibration is done in two passes
1)  First a wideband phase only calibration using channels
BChan1 to EChan1 or the central doCenter1 fraction of the band
using a solution interval of solInt1.  This solution is applied
to all selected data and used in the second pass.
2)  Second channels in the range BChan2 to EChan2 averaging blocks
of ChWid2 are calibrated using solType and solMode for solInt2 and
the results written as the output BP table.
   The Calibrator model may be given as either and Image with CC table,
a parameterized model or a point source with the flux density in 
the SU table.
See BPass documentation for details
Note: this makes no Doppler corrections - may have limited accuracy
Returns task error code, 0=OK, else failed
uv       = UV data object to calibrate
BPCal    = Bandpass calibrator, name or list of names
err      = Obit error/message stack
CalModel = python dict with image model dicts keyed on calibrator name
           image object = "Image"
           also optional
           "nfield",    Calibrator model  No. maps to use for model
           "CCver",     Calibrator model CC file version
           "BComp",     Calibrator model First CLEAN comp to use, 1/field
           "EComp"      Calibrator model  Last CLEAN comp to use, 0={\textgreater}all
           "Cmethod"    Calibrator model Modeling method, 'DFT','GRID','    '
           "CModel"     Calibrator model Model type: 'COMP','IMAG'
           "CalFlux"    Calibrator model  Lowest CC component used
           "modelFlux"  if ["Image"]=None, Parameterized model flux density (Jy)
           "modepPos"   if ["Image"]=None, Parameterized model Model position offset (asec)
           "modelParm"  if ["Image"]=None, Parameterized model Model parameters
                        (maj, min, pa, type)
newBPVer = output BP table, should be set for multiple calibrators w/ model
doCalib  = Apply calibration table, positive={\textgreater}calibrate
gainUse  = CL/SN table to apply
doBand   = If {\textgreater}0.5 apply previous bandpass cal.
BPVer    = previous Bandpass table (BP) version
flagVer  = Input Flagging table version
timerange= timerange in days to use
doCenter1= If defined, the center fraction of the bandpass to use first pass
BChan1   = Low freq. channel,  initial cal
EChan1   = Highest freq channel, initial cal
BChan2   = Low freq. channel for BP cal
EChan2   = Highest freq channel for BP cal
ChWid2   = Number of channels in running mean BP soln, 
solInt1  = first solution interval (min), 0={\textgreater} scan average
solInt2  = second solution interval (min)
solMode  = solution mode 'A\&P', 'P', 'P!A'
refAnt   = Reference antenna
ampScalar= If true, scalar average data in calibration
specIndex= spectral index of calibrator (steep=-0.70)
doAuto   = Use autocorrelation spectra? Else, crosscorrelation
doPol    = Apply polarization cal?
avgPol   = Avg. poln. in solutions?
avgIF    = Avg. IFs. in solutions?
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input
nThreads = Number of threads to use
noScrat  = list of AIPS disks to avoid for scratch files
logfile  = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBACal}
    \index{VLBACal \textit{(module)}!VLBACal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBACal}(\textit{uv}, \textit{target}, \textit{ACal}, \textit{err}, \textit{PCal}=\texttt{N\-o\-n\-e\-}, \textit{FQid}=\texttt{0\-}, \textit{calFlux}=\texttt{N\-o\-n\-e\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{calModel}=\texttt{N\-o\-n\-e\-}, \textit{calDisk}=\texttt{0\-}, \textit{solnVer}=\texttt{1\-}, \textit{solInt}=\texttt{0\-.\-1\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-}, \textit{solSmo}=\texttt{0\-.\-0\-}, \textit{nThreads}=\texttt{1\-}, \textit{refAnt}=\texttt{0\-}, \textit{ampScalar}=\texttt{F\-a\-l\-s\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Basic Amplitude and phase cal for VLBA data

Amplitude calibration can be based either on a point flux
density or a calibrator model.
If neither calFlux nor calModel is given, an attempt is made
to use the setjy.OPType="CALC" option.
Returns task error code, 0=OK, else failed
uv       = UV data object to calibrate
target   = Target source name or list of names to calibrate
ACal     = Amp calibrator
err      = Obit error/message stack
PCal     = if given, the phase calibrator name
FQid     = Frequency Id to process, 0={\textgreater}any
calFlux  = ACal point flux density if given
calModel = Amp. calibration model FITS file
           Has priority over calFlux
calDisk  = FITS disk for calModel
doCalib  = Apply calibration table, positive={\textgreater}calibrate
gainUse  = CL/SN table to apply
doBand   = If {\textgreater}0.5 apply previous bandpass cal.
BPVer    = previous Bandpass table (BP) version
flagVer  = Flagging table to apply
solnVer  = output SN table version (+1 if smooth)
solInt   = solution interval (min)
solSmo   = if solSmo{\textless}solInt smooth solutions to solSmo
nThreads = Number of threads to use
refAnt   = Reference antenna
ampScalar= If true, scalar average data in calibration
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input
noScrat  = list of disks to avoid for scratch files
logfile  = Log file for tasks\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBACalAvg}
    \index{VLBACal \textit{(module)}!VLBACalAvg \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBACalAvg}(\textit{uv}, \textit{avgClass}, \textit{avgSeq}, \textit{CalAvgTime}, \textit{err}, \textit{FQid}=\texttt{0\-}, \textit{flagVer}=\texttt{0\-}, \textit{doCalib}=\texttt{2\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{1\-}, \textit{BPVer}=\texttt{0\-}, \textit{BIF}=\texttt{1\-}, \textit{EIF}=\texttt{0\-}, \textit{BChan}=\texttt{1\-}, \textit{EChan}=\texttt{0\-}, \textit{FOV}=\texttt{0\-.\-0\-1\-}, \textit{maxFact}=\texttt{1\-.\-0\-0\-4\-}, \textit{avgFreq}=\texttt{0\-}, \textit{chAvg}=\texttt{1\-}, \textit{Compress}=\texttt{F\-a\-l\-s\-e\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Calibrate and baseline dependent average data to a multisource file

Returns task error code, 0=OK, else failed
Generates NX and initial dummy CL table
uv         = UV data object to clear
avgClass   = Class name of averaged data
avgSeq     = Sequence number of averaged data
CalAvgTime = Averaging time in sec
err        = Obit error/message stack
FQid       = Frequency Id to process, 0={\textgreater}all
doCalib    = Apply calibration table, positive={\textgreater}calibrate
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply previous bandpass cal.
BPVer      = previous Bandpass table (BP) version
BIF        = first IF to copy
EIF        = highest IF to copy
BChan      = first channel to copy
EChan      = highest channel to copy
flagVer    = Input Flagging table version
FOV        = Undistorted Field of View (deg)
maxFact    = max. allowed amp distortion
avgFreq    = If 0 {\textless} avgFreq {\textless}= 1 then average channels
chAvg      = Number of channels to average
Compress   = Write "Compressed" data?
logfile    = Log file for task
check      = Only check script, don't execute tasks
debug      = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBACalAvg2}
    \index{VLBACal \textit{(module)}!VLBACalAvg2 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBACalAvg2}(\textit{uv}, \textit{avgClass}, \textit{avgSeq}, \textit{CalAvgTime}, \textit{err}, \textit{Source}=\texttt{N\-o\-n\-e\-}, \textit{FQid}=\texttt{0\-}, \textit{doPol}=\texttt{F\-a\-l\-s\-e\-}, \textit{flagVer}=\texttt{0\-}, \textit{doCalib}=\texttt{2\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{1\-}, \textit{BPVer}=\texttt{0\-}, \textit{BIF}=\texttt{1\-}, \textit{EIF}=\texttt{0\-}, \textit{BChan}=\texttt{1\-}, \textit{EChan}=\texttt{0\-}, \textit{chAvg}=\texttt{1\-}, \textit{Compress}=\texttt{F\-a\-l\-s\-e\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Calibrate and average data to a multisource file

Returns task error code, 0=OK, else failed
Generates NX and initial dummy CL table
uv         = UV data object to clear
avgClass   = Class name of averaged data
avgSeq     = Sequence number of averaged data
CalAvgTime = Averaging time in sec
err        = Obit error/message stack
Source     = Selected source or list of sources
FQid       = Frequency Id to process, 0={\textgreater}all
doPol      = Calibratio polarization?
doCalib    = Apply calibration table, positive={\textgreater}calibrate
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply previous bandpass cal.
BPVer      = previous Bandpass table (BP) version
BIF        = first IF to copy
EIF        = highest IF to copy
BChan      = first channel to copy
EChan      = highest channel to copy
flagVer    = Input Flagging table version
Compress   = Write "Compressed" data?
logfile    = Log file for task
check      = Only check script, dont execute tasks
debug      = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAClearCal}
    \index{VLBACal \textit{(module)}!VLBAClearCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAClearCal}(\textit{uv}, \textit{err}, \textit{doGain}=\texttt{T\-r\-u\-e\-}, \textit{doBP}=\texttt{F\-a\-l\-s\-e\-}, \textit{doFlag}=\texttt{F\-a\-l\-s\-e\-}, \textit{logfile}=\texttt{N\-o\-n\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Clear previous calibration

Delete all SN tables, all CL but CL 1
uv       = UV data object to clear
err      = Obit error/message stack
doGain   = If True, delete SN and CL tables
doBP     = If True, delete BP tables
doFlag   = If True, delete FG tables except FG=1
logfile  = logfile for messages
check    = Only check script, don't execute tasks\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAClipSN}
    \index{VLBACal \textit{(module)}!VLBAClipSN \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAClipSN}(\textit{uv}, \textit{SNver}, \textit{Flag}, \textit{err}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Flag SN table entries with real {\textless} Flag

Returns with err set on error
uv         = UV data object
SNver      = SN table to flag
Flag       = if {\textgreater}0.0 flag SN table entries with real{\textless}Flag
err        = Python Obit Error/message stack
logfile    = logfile for messages
check      = Only check script
debug      = Only debug - no effect\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBACopyFG}
    \index{VLBACal \textit{(module)}!VLBACopyFG \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBACopyFG}(\textit{uv}, \textit{err}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Copy AIPS FG table from 1 to 2

Returns task error code, 0=OK, else failed
uv       = UV data object to copy
err      = Obit error/message stack
logfile  = logfile for messages
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBADelayCal}
    \index{VLBACal \textit{(module)}!VLBADelayCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBADelayCal}(\textit{uv}, \textit{err}, \textit{solInt}=\texttt{0\-.\-5\-}, \textit{smoTime}=\texttt{1\-0\-.\-0\-}, \textit{calSou}=\texttt{N\-o\-n\-e\-}, \textit{CalModel}=\texttt{N\-o\-n\-e\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{FreqID}=\texttt{1\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{minSNR}=\texttt{5\-.\-0\-}, \textit{refAnts}=\texttt{[\-0\-]\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{doSNPlot}=\texttt{F\-a\-l\-s\-e\-}, \textit{plotFile}=\texttt{'\-.\-/\-D\-e\-l\-a\-y\-C\-a\-l\-.\-p\-s\-'\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Group delay calibration

Determine delay corrections from a list of calibrators
Solutions smoothed to smoTime
Apply this SN table to the highest CL table writing a new CL table (Obit/CLCal)
Returns task error code, 0=OK, else failed
err        = Python Obit Error/message stack
calSou     = Source name or list of names to use
CalModel = python dict with image model dicts keyed on calibrator name
           image object = "Image"
           also optional
           "nfield",    Calibrator model  No. maps to use for model
           "CCver",     Calibrator model CC file version
           "BComp",     Calibrator model First CLEAN comp to use, 1/field
           "EComp"      Calibrator model  Last CLEAN comp to use, 0={\textgreater}all
           "Cmethod"    Calibrator model Modeling method, 'DFT','GRID','    '
           "CModel"     Calibrator model Model type: 'COMP','IMAG'
           "CalFlux"    Calibrator model  Lowest CC component used
           "modelFlux"  if ["Image"]=None, Parameterized model flux density (Jy)
           "modepPos"   if ["Image"]=None, Parameterized model Model position offset (asec)
           "modelParm"  if ["Image"]=None, Parameterized model Model parameters
                        (maj, min, pa, type)
timeRange  = timerange of data to use
solInt     = Calib solution interval (min)
smoTime    = Smoothing time applied to SN table (min)
FreqID     = Frequency group identifier
minSNR     = minimum acceptable SNR in Calib
refAnts    = List of reference antennas
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
doSNPlot   = If True make plots of SN gains
plotFile   = Name of postscript file for plots
nThreads   = Max. number of threads to use
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBADoppler}
    \index{VLBACal \textit{(module)}!VLBADoppler \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBADoppler}(\textit{uv}, \textit{err}, \textit{Sources}=\texttt{N\-o\-n\-e\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-]\-}, \textit{FreqID}=\texttt{1\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Diurnal Doppler corrections

Determine and apply Doppler corrections producing a new output file, class = "CVel"
Returns task error code, 0=OK, else failed
err        = Python Obit Error/message stack
Sources    = if given, the list of sources to shift
timeRange  = (AIPS style) timerange of data to use
FreqID     = Frequency group identifier
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAFreqInfo}
    \index{VLBACal \textit{(module)}!VLBAFreqInfo \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAFreqInfo}(\textit{uv}, \textit{restFreq}, \textit{srcVel}, \textit{err}, \textit{FreqID}=\texttt{1\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{Compress}=\texttt{F\-a\-l\-s\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Set lost frequency/velocity infortmation

Update AIPS SU table, spectrum assumes centered on velocities given
Returns task error code, 0=OK, else failed
uv         = UV data object
restFreq   = list of rest frequencies per IF (Hz)
srcVel     = list of src name plus velocities (Km/s) and Flux densities (Jy), 
             eg [("myStar", (0.0,0.0), (1.0,1.0))]  
err        = Python Obit Error/message stack
FreqID     = Frequency group identifier
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAGoodCal}
    \index{VLBACal \textit{(module)}!VLBAGoodCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAGoodCal}(\textit{uv}, \textit{err}, \textit{solInt}=\texttt{0\-.\-5\-}, \textit{timeInt}=\texttt{1\-0\-0\-.\-0\-}, \textit{FreqID}=\texttt{1\-}, \textit{calSou}=\texttt{N\-o\-n\-e\-}, \textit{CalModel}=\texttt{N\-o\-n\-e\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{minSNR}=\texttt{1\-0\-.\-0\-}, \textit{refAnts}=\texttt{[\-0\-]\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Find best calibration source and timerange and best refAnt

Determines good calibrator source and timerange and best
reference antenna by running a phase Calib and looking at the
SNRs of the solutions.
Return dict \{"Source":source, "souID":souID, "timeRange":(tbeg,tend),                 "Fract":fract\_OK, "SNR":avg\_SNR,"bestRef":refAnt\}
            or None on failure
uv         = UV data object
err        = Python Obit Error/message stack
calSou     = Source name or list of names to use
CalModel = python dict with image model dicts keyed on calibrator name
           image object = "Image"
           also optional
           "nfield",    Calibrator model  No. maps to use for model
           "CCver",     Calibrator model CC file version
           "BComp",     Calibrator model First CLEAN comp to use, 1/field
           "EComp"      Calibrator model  Last CLEAN comp to use, 0={\textgreater}all
           "Cmethod"    Calibrator model Modeling method, 'DFT','GRID','    '
           "CModel"     Calibrator model Model type: 'COMP','IMAG'
           "CalFlux"    Calibrator model  Lowest CC component used
           "modelFlux"  if ["Image"]=None, Parameterized model flux density (Jy)
           "modepPos"   if ["Image"]=None, Parameterized model Model position offset (asec)
           "modelParm"  if ["Image"]=None, Parameterized model Model parameters
                        (maj, min, pa, type)
solInt     = Calib solution interval (min)
timeInt    = interval width (min) to use for timerange (large={\textgreater}scan)
FreqID     = Frequency group identifier
minSNR     = minimum acceptable SNR in Calib
refAnts    = List of reference antennas in priority order,
             Also, if values given then list of acceptable ref. ants
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
nThreads   = Max. number of threads to use
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAIDILoad}
    \index{VLBACal \textit{(module)}!VLBAIDILoad \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAIDILoad}(\textit{filename}, \textit{project}, \textit{session}, \textit{band}, \textit{Aclass}, \textit{Adisk}, \textit{Aseq}, \textit{err}, \textit{wtThresh}=\texttt{0\-.\-8\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-4\-}, \textit{calInt}=\texttt{1\-.\-0\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{Compress}=\texttt{F\-a\-l\-s\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Read FITS IDI file into AIPS

Read a IDI FITS UV data file and write an AIPS data set
AIPS file name will be project+session with project truncated to fit in 12 characters
Returns AIPS data file
filename   = name of FITS file
project    = project name
session    = session code
band       = observing band code
Aclass     = AIPS class of file
Aseq       = AIPS sequence number of file, 0={\textgreater} create new
Adisk      = FITS directory number
err        = Python Obit Error/message stack
logfile    = logfile for messages
wtThresh   = Data weight threshold
calInt     = CL entry interval (min)
Compress   = Write AIPS data in compressed form?
check      = Only check script, don't execute tasks
debug      = show input
returns AIPS UV data object\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAImageCals}
    \index{VLBACal \textit{(module)}!VLBAImageCals \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAImageCals}(\textit{uv}, \textit{err}, \textit{FreqID}=\texttt{1\-}, \textit{Sources}=\texttt{N\-o\-n\-e\-}, \textit{seq}=\texttt{1\-}, \textit{sclass}=\texttt{'\-I\-m\-g\-S\-C\-'\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{FOV}=\texttt{2\-.\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-7\-9\-e\--\-0\-5\-}, \textit{Robust}=\texttt{0\-}, \textit{Niter}=\texttt{3\-0\-0\-}, \textit{maxPSCLoop}=\texttt{6\-}, \textit{minFluxPSC}=\texttt{0\-.\-1\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-1\-}, \textit{solPInt}=\texttt{0\-.\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-3\-1\-}, \textit{solMode}=\texttt{'\-P\-'\-}, \textit{maxASCLoop}=\texttt{1\-}, \textit{minFluxASC}=\texttt{0\-.\-5\-}, \textit{solAInt}=\texttt{2\-.\-0\-}, \textit{avgPol}=\texttt{F\-a\-l\-s\-e\-}, \textit{avgIF}=\texttt{F\-a\-l\-s\-e\-}, \textit{minSNR}=\texttt{5\-.\-0\-}, \textit{refAnt}=\texttt{0\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Image a list of sources

Uses SCMap to image a list of sources.
Returns task error code, 0=OK, else failed

uv         = UV data object
err        = Python Obit Error/message stack
Sources    = Source name or list of names to use
seq        = sequence number of output
sclass     = Image output class
FreqID     = Frequency group identifier
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
FOV        = Field of view to image in deg
Robust     = Weighting robustness parameter
Niter      = max no. iterations
maxPSCLoop = max. number of phase sc loops
minFluxPSC = Trip level for phase self cal (Jy)
solPInt    = Phase solution interval (min)
solMode    = Phase soln mode "P", "DELA"
maxASCLoop = max. number of amp\&phase sc loops
minFluxASC = Trip level for amp\&phase self cal (Jy)
solAInt    = Amp\&phase solution interval (min)
avgPol     = Average poln in SC?
avgIF      = Average IFs in SC?
minSNR     = minimum acceptable SNR in SC
refAnt     = Reference antenna
nThreads   = Max. number of threads to use
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAImageModel}
    \index{VLBACal \textit{(module)}!VLBAImageModel \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAImageModel}(\textit{snames}, \textit{sclass}, \textit{sdisk}, \textit{sseq}, \textit{err}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Generate Dict of image Models from images

Create a source list dict with source models for AIPS images.
Creates an image object for each image found matching criteria
Return python dict with image model dicts keyed on source name,
image object = "Image"
names      = source name or list of names, None=noop
sclass     = image class
sdisk      = image disk
sseq       = image sequence
err        = Python Obit Error/message stack
logfile    = logfile for messages
check      = Only check script
debug      = Only debug - no effect\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAImFITS}
    \index{VLBACal \textit{(module)}!VLBAImFITS \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAImFITS}(\textit{inImage}, \textit{filename}, \textit{outDisk}, \textit{err}, \textit{fract}=\texttt{N\-o\-n\-e\-}, \textit{quant}=\texttt{N\-o\-n\-e\-}, \textit{exclude}=\texttt{[\-'\-A\-I\-P\-S\-~\-H\-I\-'\-,\-~\-'\-A\-I\-P\-S\-~\-P\-L\-'\-,\-~\-'\-A\-I\-P\-S\-~\-S\-L\-'\-]\-}, \textit{include}=\texttt{[\-'\-A\-I\-P\-S\-~\-C\-C\-'\-]\-}, \textit{headHi}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Write AIPS image as FITS

Write a Image data set as a FITAB format file
History also copied
inImage    = Image data to copy
filename   = name of FITS file, any whitespace characters replaced with underscore
outDisk    = FITS directory number
err        = Python Obit Error/message stack
fract      = Fraction of RMS to quantize
quant      = quantization level in image units, has precedence over fract
             None or {\textless}= 0 ={\textgreater} use fract.
exclude    = List of table types NOT to copy
             NB: "AIPS HI" isn't really a table and gets copied anyway
include    = List of table types to copy
headHi     = if True move history to header, else leave in History table\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAManPCal}
    \index{VLBACal \textit{(module)}!VLBAManPCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAManPCal}(\textit{uv}, \textit{err}, \textit{solInt}=\texttt{0\-.\-5\-}, \textit{smoTime}=\texttt{1\-0\-.\-0\-}, \textit{calSou}=\texttt{N\-o\-n\-e\-}, \textit{CalModel}=\texttt{N\-o\-n\-e\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{FreqID}=\texttt{1\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{minSNR}=\texttt{1\-0\-.\-0\-}, \textit{refAnts}=\texttt{[\-0\-]\-}, \textit{doBand}=\texttt{-\-1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Manual phase cal

Determine phase corrections from a short section of strong source data.
Apply this SN table to the highest CL table writing a new CL table (Obit/CLCal)
Returns task error code, 0=OK, else failed
err        = Python Obit Error/message stack
calSou     = Source name or list of names to use
CalModel = python dict with image model dicts keyed on calibrator name
           image object = "Image"
           also optional
           "nfield",    Calibrator model  No. maps to use for model
           "CCver",     Calibrator model CC file version
           "BComp",     Calibrator model First CLEAN comp to use, 1/field
           "EComp"      Calibrator model  Last CLEAN comp to use, 0={\textgreater}all
           "Cmethod"    Calibrator model Modeling method, 'DFT','GRID','    '
           "CModel"     Calibrator model Model type: 'COMP','IMAG'
           "CalFlux"    Calibrator model  Lowest CC component used
           "modelFlux"  if ["Image"]=None, Parameterized model flux density (Jy)
           "modepPos"   if ["Image"]=None, Parameterized model Model position offset (asec)
           "modelParm"  if ["Image"]=None, Parameterized model Model parameters
                        (maj, min, pa, type)
timeRange  = timerange of data to use
solInt     = Calib solution interval (min)
smoTime    = Smoothing time applied to SN table (min)
FreqID     = Frequency group identifier
minSNR     = minimum acceptable SNR in Calib
refAnt   = Reference antenna
doCalib    = Apply calibration table
gainUse    = CL/SN table to apply
doBand     = If {\textgreater}0.5 apply bandpass cal.
BPVer      = Bandpass table version
flagVer    = Input Flagging table version
nThreads   = Max. number of threads to use
noScrat    = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAMedianFlag}
    \index{VLBACal \textit{(module)}!VLBAMedianFlag \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAMedianFlag}(\textit{uv}, \textit{target}, \textit{err}, \textit{flagTab}=\texttt{2\-}, \textit{flagSig}=\texttt{1\-0\-.\-0\-}, \textit{alpha}=\texttt{0\-.\-5\-}, \textit{timeWind}=\texttt{2\-.\-0\-}, \textit{doCalib}=\texttt{0\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{avgTime}=\texttt{0\-}, \textit{avgFreq}=\texttt{0\-}, \textit{chAvg}=\texttt{1\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Does Median window flagging

Flag data based on deviations from a running median
See documentation for task MednFlag for details
Returns task error code, 0=OK, else failed
uv       = UV data object to flag
target   = Target source name or list of names, blank = all
err      = Obit error/message stack
flagTab  = Output Flagging table version
flagSig  = Flagging level (sigma)
alpha    = Smoothing parameter
timeWind = Averaging window (min)
doCalib  = Apply calibration table
gainUse  = CL/SN table to apply
doBand   = If {\textgreater}0.5 apply bandpass cal.
BPVer    = Bandpass table version
flagVer  = Input Flagging table version
avgTime  = preaveraging time (min)
avgFreq  = 1={\textgreater}avg chAvg chans, 2={\textgreater}avg all chan, 3={\textgreater} avg chan and IFs
chAvg    = number of channels to average
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input
nThreads = Number of threads to use
noScrat  = list of disks to avoid for scratch files
logfile  = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAOpacCor}
    \index{VLBACal \textit{(module)}!VLBAOpacCor \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAOpacCor}(\textit{uv}, \textit{OpacSmoo}, \textit{err}, \textit{FreqID}=\texttt{1\-}, \textit{WXver}=\texttt{0\-}, \textit{TYver}=\texttt{0\-}, \textit{GCver}=\texttt{0\-}, \textit{doSNPlot}=\texttt{F\-a\-l\-s\-e\-}, \textit{plotFile}=\texttt{'\-.\-/\-O\-p\-a\-c\-i\-t\-y\-.\-p\-s\-'\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Make Opacity/gain correction from TY/GC table

Creates new SN table, smooths, applies to highest numbered Cl 
and writes new CL
Returns task error code, 0=OK, else failed
uv         = UV data object
OpacSmoo   = Smoothing time (hr) for SN table
err        = Python Obit Error/message stack
FreqID     = Frequency group identifier
TYver      = TY version to use, 0={\textgreater} highest
GCver      = GC version to use, 0={\textgreater} highest
WXver      = WX version to use, 0={\textgreater} highest, -1={\textgreater}none
doSNPlot   = If True make plots of SN gains
plotFile   = Name of postscript file for plots
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAPACor}
    \index{VLBACal \textit{(module)}!VLBAPACor \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAPACor}(\textit{uv}, \textit{err}, \textit{CLver}=\texttt{0\-}, \textit{FreqID}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Make parallactic angle correction

Updates CL CLver
Returns task error code, 0=OK, else failed
uv         = UV data object
err        = Python Obit Error/message stack
CLver      = Cl version to update, 0={\textgreater} highest
FreqID     = Frequency group identifier
noScrat  = list of disks to avoid for scratch files
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAPlotTab}
    \index{VLBACal \textit{(module)}!VLBAPlotTab \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAPlotTab}(\textit{uv}, \textit{inext}, \textit{invers}, \textit{err}, \textit{source}=\texttt{N\-o\-n\-e\-}, \textit{timerang}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{optype}=\texttt{'\-~\-~\-~\-~\-'\-}, \textit{opcode}=\texttt{'\-~\-~\-~\-~\-'\-}, \textit{nplots}=\texttt{1\-}, \textit{logfile}=\texttt{N\-o\-n\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Makes AIPS plots of tables

Returns task error code, 0=OK, else failed
uv       = UV data object to plot
inext    = AIPS Table ("SN", "CL", "TY", "PC")
inver    = version number, 0-{\textgreater} highest
source   = if given the name of the source
timerang = timerange to plot.
optype   = Data to be plotted (see help snplt)
opcode   = Plot type (see help snplt)
nplots   = number of plots per page
err      = Obit error/message stack
logfile  = logfile for messages
check    = Only check script, don't execute tasks
debug    = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAPolCal}
    \index{VLBACal \textit{(module)}!VLBAPolCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAPolCal}(\textit{uv}, \textit{InsCals}, \textit{err}, \textit{RM}=\texttt{0\-.\-0\-}, \textit{doCalib}=\texttt{2\-}, \textit{gainUse}=\texttt{0\-}, \textit{doBand}=\texttt{1\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{soltype}=\texttt{'\-A\-P\-P\-R\-'\-}, \textit{fixPoln}=\texttt{F\-a\-l\-s\-e\-}, \textit{avgIF}=\texttt{F\-a\-l\-s\-e\-}, \textit{solInt}=\texttt{0\-.\-0\-}, \textit{refAnt}=\texttt{0\-}, \textit{pmodel}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Instrumental Polarization 

Do Instrumental
Instrumental cal uses PCAL, R-L cal is done by imaging each IF in Q and U
and summing the CLEAN components.
Returns task error code, 0=OK, else failed
uv       = UV data object to calibrate
InsCals  = Instrumental poln calibrators, name or list of names
           If None no instrumental cal
err      = Obit error/message stack
RM       = Rotation measure of RLCal
doCalib  = Apply prior calibration table, positive={\textgreater}calibrate
gainUse  = CL/SN table to apply
doBand   = {\textgreater}0 ={\textgreater} apply bandpass calibration
BPVer    = AIPS BP table to apply
flagVer  = Input Flagging table version
soltype  = solution type
fixPoln  = if True, don't solve for source polarization in ins. cal
avgIF    = if True, average IFs in ins. cal.
solInt   = instrumental solution interval (min), 0={\textgreater} scan average
refAnt   = Reference antenna
pmodel   = Instrumental poln cal source poln model.
           pmodel[0] = I flux density (Jy)
           pmodel[1] = Q flux density (Jy)
           pmodel[2] = U flux density (Jy)
           pmodel[3] = V flux density (Jy)
           pmodel[4] = X offset in sky (arcsec)
           pmodel[5] = Y offset in sky (arcsec)
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input
noScrat  = list of disks to avoid for scratch files
logfile  = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAQuack}
    \index{VLBACal \textit{(module)}!VLBAQuack \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAQuack}(\textit{uv}, \textit{err}, \textit{Stokes}=\texttt{'\-~\-'\-}, \textit{BIF}=\texttt{1\-}, \textit{EIF}=\texttt{0\-}, \textit{Sources}=\texttt{[\-'\-~\-~\-'\-]\-}, \textit{FreqID}=\texttt{0\-}, \textit{subA}=\texttt{0\-}, \textit{timeRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{Antennas}=\texttt{[\-0\-]\-}, \textit{flagVer}=\texttt{2\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-}, \textit{begDrop}=\texttt{0\-.\-0\-}, \textit{endDrop}=\texttt{0\-.\-0\-}, \textit{Reason}=\texttt{'\-Q\-u\-a\-c\-k\-'\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Flags beginning and end of each scan

Trim start and end of each selected scan,
nothing done if begDrop=endDrop=0.0
See documentation for task Quack for details
Returns task error code, 0=OK, else failed
uv       = UV data object to flag
err      = Obit error/message stack
Stokes   = Limit flagging by Stokes
BIF      = Limit flagging to BIF-EIF
EIF      = Limit flagging
Sources  = Sources selected
subA     = Subarray number 0={\textgreater}all
FreqID   = Freq. ID to flag. -1={\textgreater}all
timeRange= Time range to process
Antennas = List of antennas to include
flagVer  = Flag table version, 0 ={\textgreater} highest
begDrop  = Time (min) to drop from beginning
endDrop  = Time (min) to drop from end
Reason   = Reason (max 24 char.)
logfile  = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAQuantCor}
    \index{VLBACal \textit{(module)}!VLBAQuantCor \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAQuantCor}(\textit{uv}, \textit{QuantSmoo}, \textit{QuantFlag}, \textit{err}, \textit{doSNPlot}=\texttt{F\-a\-l\-s\-e\-}, \textit{plotFile}=\texttt{'\-.\-/\-Q\-u\-a\-n\-t\-.\-p\-s\-'\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Determine/apply quantization correstion, possibly with flagging

Determine quantization corrections using AIPS/ACCOR to new SN table
Smooth derived SN table (Obit/SNSmo) to QuamntSmoo
If QuantFlag, then the SN table is flagged with values below QuantFlag
Apply this SN table to the highest CL table writing a new CL table (Obit/CLCal)
Returns task error code, 0=OK, else failed
uv         = UV data object
QuantSmoo  = Smoothing time in Hr
QuantFlag  = if {\textgreater}0.0 flag SN table entries with real{\textless}QuantFlag
err        = Python Obit Error/message stack
doSNPlot   = If True make plots of SN gains
plotFile   = Name of postscript file for plots
logfile    = logfile for messages
check      = Only check script, don't execute tasks
debug      = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBARefMB}
    \index{VLBACal \textit{(module)}!VLBARefMB \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBARefMB}(\textit{uv}, \textit{SNver}, \textit{err}, \textit{smoTime}=\texttt{1\-e\-+\-2\-0\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Average delays and reference phases to first IF

Averages all delays per antenna/Poln/IF in an SN table and 
referes all phases to IF 1 (or first IF with valid data).
This preserves multiband delays but removes phase fluctuations in time.
Intended for use for a single scan SN table
Returns with err set on error
uv         = UV data object
SNver      = SN table to modify
err        = Python Obit Error/message stack
smoTime    = Averaging interval (min)
logfile    = logfile for messages
check      = Only check script
debug      = Only debug - no effect\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBARLCal}
    \index{VLBACal \textit{(module)}!VLBARLCal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBARLCal}(\textit{uv}, \textit{err}, \textit{RLPCal}=\texttt{N\-o\-n\-e\-}, \textit{RLPhase}=\texttt{0\-.\-0\-}, \textit{RM}=\texttt{0\-.\-0\-}, \textit{BChan}=\texttt{1\-}, \textit{EChan}=\texttt{0\-}, \textit{ChWid}=\texttt{1\-}, \textit{solInt1}=\texttt{0\-.\-1\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-6\-}, \textit{solInt2}=\texttt{1\-0\-.\-0\-}, \textit{UVRange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{WtUV}=\texttt{0\-.\-0\-}, \textit{FQid}=\texttt{0\-}, \textit{calcode}=\texttt{'\-~\-~\-~\-~\-'\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{timerange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{Antennas}=\texttt{N\-o\-n\-e\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{BPSoln}=\texttt{0\-}, \textit{refAnt}=\texttt{0\-}, \textit{doPol}=\texttt{-\-1\-}, \textit{smooth}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Determine R-L phase bandpass

Returns task error code, 0=OK, else failed
Determines new BP table
uv       = UV data object to clear
err      = Obit error/message stack
RLPCal   = R-L (polarization angle) calibrator,
RLPhase  = R-L phase of RLPCal (deg) at 1 GHz
RM       = Rotation measure of RLPCal (rad/m{\textasciicircum}2)
BChan    = First (1-rel) channel number
EChan    = Highest channel number. 0={\textgreater} high in data.
ChWid    = Number of channels to average to determine soln.
solInt1  = first solution interval (min), 0={\textgreater} scan average
solInt2  = second solution interval (min)
UVRange  = Range of baseline used in kilowavelengths
WTUV     = Weight to use outside of UVRange
FQid     = Frequency Id to process
calcode  = Calibrator code
doCalib  = Apply calibration table, positive={\textgreater}calibrate
gainUse  = CL/SN table to apply
timerange= time range of data (days)
Antennas = if given, a list of antennas to use
doBand   = If {\textgreater}0.5 apply previous bandpass cal.
BPVer    = previous Bandpass table (BP) version
BPSoln   = Output BP table, 0={\textgreater}new
flagVer  = Flagging table to apply
refAnt   = Reference antenna REQUIRED
doPol    = Apply polarization cal?
smooth   = Channel smoothing function
noScrat  = list of AIPS disks to avoid for scratch files
nThreads = Number of threads to use in imaging
logfile  = Log file for task
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBARLCal2}
    \index{VLBACal \textit{(module)}!VLBARLCal2 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBARLCal2}(\textit{uv}, \textit{err}, \textit{RLDCal}=\texttt{N\-o\-n\-e\-}, \textit{BChan}=\texttt{1\-}, \textit{EChan}=\texttt{0\-}, \textit{FQid}=\texttt{0\-}, \textit{calcode}=\texttt{'\-~\-~\-~\-~\-'\-}, \textit{doCalib}=\texttt{-\-1\-}, \textit{gainUse}=\texttt{0\-}, \textit{timerange}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{doBand}=\texttt{0\-}, \textit{BPVer}=\texttt{0\-}, \textit{flagVer}=\texttt{-\-1\-}, \textit{refAnt}=\texttt{0\-}, \textit{doPol}=\texttt{-\-1\-}, \textit{smooth}=\texttt{[\-0\-.\-0\-,\-~\-0\-.\-0\-,\-~\-0\-.\-0\-]\-}, \textit{dataInt}=\texttt{0\-.\-0\-}, \textit{RLPCal}=\texttt{N\-o\-n\-e\-}, \textit{RLPhase}=\texttt{0\-.\-0\-}, \textit{FOV}=\texttt{0\-.\-0\-5\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-3\-}, \textit{niter}=\texttt{1\-0\-0\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Determine R-L delay and phase calibration

Returns task error code, 0=OK, else failed
Calibration applies to (new) highest numbered CL table on uv
uv       = UV data object to clear
err      = Obit error/message stack
RLPCal   = R-L (polarization angle) calibrator,
           If None no R-L cal
RLPhase  = R-L phase of RLPCal (deg) at 1 GHz
RLDCal   = R-L delay calibrator name or list
           If None no R-L delay cal
BChan    = First (1-rel) channel number
EChan    = Highest channel number. 0={\textgreater} high in data.
FQid     = Frequency Id to process
calcode  = Calibrator code
doCalib  = Apply calibration table, positive={\textgreater}calibrate
gainUse  = CL/SN table to apply
timerange= time range of data (aips format)
doBand   = If {\textgreater}0.5 apply previous bandpass cal.
BPVer    = previous Bandpass table (BP) version
flagVer  = Flagging table to apply
refAnt   = Reference antenna REQUIRED
doPol    = Apply polarization cal?
smooth   = Channel smoothing function
dataInt  = Data integration time (sec)
FOV      = field of view radius (deg) needed to image RLPCal
niter    = Number  of iterations of CLEAN in R-L cal
noScrat  = list of AIPS disks to avoid for scratch files
nThreads = Number of threads to use in imaging
logfile  = Log file for task
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBASetImager}
    \index{VLBACal \textit{(module)}!VLBASetImager \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBASetImager}(\textit{uv}, \textit{target}, \textit{outIclass}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{nThreads}=\texttt{1\-}, \textit{noScrat}=\texttt{[\-]\-}, \textit{logfile}=\texttt{'\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Setup to run Imager

return MFImage task interface object
uv       = UV data object to image
target   = Target source name or list of names
outIclass= output class
FQid     = Frequency Id to process
nThreads = Number of threads to use
noScrat  = list of disks to avoid for scratch files
logfile  = Log file for task\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBASNStats}
    \index{VLBACal \textit{(module)}!VLBASNStats \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBASNStats}(\textit{uv}, \textit{SNver}, \textit{solInt}, \textit{err}, \textit{refAnts}=\texttt{[\-0\-]\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Find good timerange on the basis of an SN table

Returns with err set on error
Return dict \{"Source":source, "souID":souID, "timeRange":(tbeg,tend),                   "Fract":fract\_OK, "SNR":avg\_SNR,"bestRef":refAnt\}
If there is no SU table or source ID not in table, source name is blank
uv         = UV data object
SNver      = SN table to flag
solInt     = statistics interval (min)
refAnts    = If values given, then list of acceptable ref. ants
err        = Python Obit Error/message stack
logfile    = logfile for messages
check      = Only check script
debug      = Only debug - no effect\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBASplit}
    \index{VLBACal \textit{(module)}!VLBASplit \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBASplit}(\textit{uv}, \textit{target}, \textit{err}, \textit{FQid}=\texttt{1\-}, \textit{outClass}=\texttt{'\-~\-~\-~\-~\-~\-~\-'\-}, \textit{logfile}=\texttt{'\-'\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Write calibrated data

Returns task error code, 0=OK, else failed
uv       = UV data object to clear
target   = Target source name source name or list of names
err      = Obit error/message stack
FQid     = Frequency Id to process
logfile  = Log file for task
check    = Only check script, don't execute tasks
debug    = Run tasks debug, show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAUVFITS}
    \index{VLBACal \textit{(module)}!VLBAUVFITS \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAUVFITS}(\textit{inUV}, \textit{filename}, \textit{outDisk}, \textit{err}, \textit{compress}=\texttt{F\-a\-l\-s\-e\-}, \textit{exclude}=\texttt{[\-'\-A\-I\-P\-S\-~\-H\-I\-'\-,\-~\-'\-A\-I\-P\-S\-~\-A\-N\-'\-,\-~\-'\-A\-I\-P\-S\-~\-F\-Q\-'\-,\-~\-'\-A\-I\-P\-S\-~\-S\-L\-'\-,\-~\-'\-A\-I\-P\-S\-~\-P\-L\-'\-]\-}, \textit{include}=\texttt{[\-]\-}, \textit{headHi}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Write UV data as FITS file

Write a UV data set as a FITAB format file
History written to header
inUV       = UV data to copy
filename   = name of FITS file, any whitespace characters replaced with underscore 
inDisk     = FITS directory number
err        = Python Obit Error/message stack
exclude    = List of table types NOT to copy
             NB: "AIPS HI" isn't really a table and gets copied anyway
include    = List of table types to copy (FQ, AN always done )
             Exclude has presidence over include
headHi     = if True move history to header, else leave in History table
returns FITS UV data object\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAUVFITSTab}
    \index{VLBACal \textit{(module)}!VLBAUVFITSTab \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAUVFITSTab}(\textit{inUV}, \textit{filename}, \textit{outDisk}, \textit{err}, \textit{exclude}=\texttt{[\-'\-A\-I\-P\-S\-~\-H\-I\-'\-,\-~\-'\-A\-I\-P\-S\-~\-A\-N\-'\-,\-~\-'\-A\-I\-P\-S\-~\-F\-Q\-'\-,\-~\-'\-A\-I\-P\-S\-~\-S\-L\-'\-,\-~\-'\-A\-I\-P\-S\-~\-P\-L\-'\-]\-}, \textit{include}=\texttt{[\-]\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Write Tables on UV data as FITS file

Write Tables from a UV data set (but no data) as a FITAB format file
History written to header
inUV       = UV data to copy
filename   = name of FITS file, any whitespace characters replaced with underscore 
inDisk     = FITS directory number
err        = Python Obit Error/message stack
exclude    = List of table types NOT to copy
             NB: "AIPS HI" isn't really a table and gets copied anyway
include    = List of table types to copy (FQ, AN always done )
             Exclude has presidence over include
returns FITS UV data object\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{VLBACal:VLBAWritePlots}
    \index{VLBACal \textit{(module)}!VLBAWritePlots \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{VLBAWritePlots}(\textit{uv}, \textit{loPL}, \textit{hiPL}, \textit{plotFile}, \textit{err}, \textit{logfile}=\texttt{N\-o\-n\-e\-}, \textit{check}=\texttt{F\-a\-l\-s\-e\-}, \textit{debug}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Writes plots to an external postscript file

All Plots deleted from AIPS
Returns task error code, 0=OK, else failed
uv       = UV data object to plot
loPL     = Lowest (1-rel) plot number
hiPL     = Highest PL version number (0-{\textgreater}all)
plotFile = plot file
err      = Obit error/message stack
logfile  = logfile for messages
check    = Only check script, don't execute tasks
debug    = show input\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \index{VLBACal \textit{(module)}|)}
